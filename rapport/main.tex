\documentclass{article}

% Eshtetic packages -----------------------
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=25mm,
 right=25mm,
 top=25mm,
 bottom=25mm,
 }

 % A little black magic
\usepackage{microtype}

% Other Packages --------------------------

\usepackage{stmaryrd}
\usepackage{biblatex}
\usepackage[T1]{fontenc}
\usepackage{enumitem}

\usepackage{graphicx}
\graphicspath{ {../images/} }


\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbold}
\usepackage[french]{babel}
% \usepackage[autolanguage]{numprint} % for the \nombre command
\usepackage{hyphenat}
% \usepackage{minted}
% \setminted[ocaml]{style=vs}

\usepackage{tikz}
\usetikzlibrary[cd]

% Operators -------------------------------

\let\loop\relax
\DeclareMathOperator{\loop}{loop}
\DeclareMathOperator{\transp}{transp}
\DeclareMathOperator{\inv}{inv}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\isconnected}{isConnected}
\DeclareMathOperator{\isprop}{isProp}
\DeclareMathOperator{\isset}{isSet}
\DeclareMathOperator{\isgroupoid}{isGroupoïd}
\DeclareMathOperator{\isequiv}{isEquiv}
\DeclareMathOperator{\pathtoequiv}{pathToEquiv}
\let\Pr\relax
\DeclareMathOperator{\Pr}{Pr}
\DeclareMathOperator{\shape}{shape}
\DeclareMathOperator{\gset}{G-Set}
\DeclareMathOperator{\torsor}{Torsor}
\DeclareMathOperator{\aut}{Aut}
\DeclareMathOperator{\code}{code}
\DeclareMathOperator{\decode}{decode}
\DeclareMathOperator{\transport}{transport}
\DeclareMathOperator{\refl}{refl}
\DeclareMathOperator{\baut}{BAut}
\DeclareMathOperator{\set}{Set}
\DeclareMathOperator{\prop}{Prop}
\DeclareMathOperator{\groupa}{Group}
\let\hom\relax
\DeclareMathOperator{\hom}{Hom}

% \addbibresource{bibliographie.bib}

% \captionsetup{labelformat=empty}

%\renewcommand{\labelitemi}{$\bullet$}

\newtheorem{definition}{Définition}[section]
\newtheorem{theorem}{Théorème}[section]
\newtheorem{axiom}{Axiom}[section]
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{lemme}[definition]{Lemme}
% \newtheorem{conjecture}[definition]{Conjecture}
% \newtheorem{exemple}[definition]{Exemple}


\title{A minimal construction of Eilenberg-MacLane spaces in HoTT}

\begin{document}

\section{Introduction to the Problem : Eilenberg-MacLane Spaces}

\subsection{Reminders on Topology}

Let $A$ be a topological space. We call continuous functions from $[0;1]$ to $A$ the \emph{paths of $A$}. If $x,y$ are points of $A$, we say that $\gamma : [0;1] \to A$ is a path from $x$ to $y$ if $\gamma(0) = x$ and $\gamma(1) = y$. Paths from $x$ to $x$ are called the \emph{loops} of $x$. A homotopy between two paths $p$ and $q$ is a continuous family of paths $F_{t} : [0;1] \to [0;1] \to A$ such that $F_{0} = p$ and $F_{1} = q$.

INSERT DRAWING

\subsection{The Fundamental Group}

Let us consider the loops of a point $x$ in $A$. We can concatenate paths (we need only to strecth the input interval back to $[0;1]$), and take the inverse of any path (the path that goes backwards through the same points). It is a fundemental result in algebraic topology that these paths considered up to homotopy form a group. Furthermore, the group is isomorphic for any $x$ in $A$. We call this group the \emph{fundemental group} of $A$, which we denote $\pi_{1}(A)$.

One can also define $\pi_{2}(A)$ to be the group of homotopies between loops of any $x$ in $A$, up to homotopies of homotopies, and so on for any $\pi_{n}$. ($\pi_{0}(A)$ is the set of connected components of $A$).

\subsection{Eilenberg-MacLane Spaces}

It is a non trivial fact that for any group $G$, there exists a topological space X such that :

\[
\pi_{n}(X) =
\begin{cases}
  G \text{ if } n = 1 \\
  \mathbb{1} \text{ if } n \neq 1
\end{cases}
\]

The point of this internship was to study how such a space can be constructed using the formalism of Homotopy Type Theory, and to show that a minimal construction can be achieved when given generators of the group $G$.

\section{Introduction to Homotopy Type Theory}

\subsection{What is Homotopy Type Theory?}

Types can be thought of as set-like collections, with inhabitants $x : A$ being seen as `elements' of a type. Types can be broader than sets though, one can write the type of all groups for example. To avoid Russel's paradox, we consider every type to be an element of a broader type called a universe, often denoted $\mathcal{U}$. We know from the Curry-Howard correspondance that we can also see them as propositions, with inhabitants being seen as proofs. Functions for example are proofs of implications $A \to B$, in the sense that they map proofs of $A$ to proofs of $B$. Homotopy type theory sees types as topological spaces, and inhabitants as points of that space.


\subsection{Reminders on Dependant Types}

Dependant type theory allows us to express formulas of first-order logic as types, namely it is needed for $\exists$-statements and $\forall$-statements. If $P : A \to \mathcal{U}$, ($P$ is called a `type family' over $A$), we have types:

\[\sum_{x : A}P(x) \; \; ; \; \; \prod_{x : A}P(x) \]

Called a dependant sum and dependant product. Their inhabitants are respectively: proofs of an $\exists$-stament, i.e.\ dependant pairs $(x , p)$ where $x : A$ and $p : P(x)$, and proofs of a $\forall$-statement, i.e dependant functions that map every inhabitant $x : A$ to an inhabitant of $P(x)$.

\subsection{Equality Types}

As opposed to classical logic, in type theory equality is part of the syntax. Therefor there are two notions of equality: let $x,y : A$. There is \emph{judgemental equality}, (noted $x :\equiv y$) which is used to define things, and \emph{propositional equality} (noted $x =_{A} y$ or just $x = y$) which is the kind that we proove. Judgemental equality is above the syntax: $x :\equiv y$ just means we allow ourselves to swap out the symbols at any point. However, $(x = y)$ is a type (a so called `identity type'). The type $(x = x)$ is always inhabited, namely by an inhabitant called \emph{reflexivity}: $\refl : (x = x)$. Furthemore, identity types of $A$ with $x$ on the right hand side have an induction principal $J$ called \emph{path induction}:

\[J : \prod_{P : \prod_{y : A} (x = y) \to \mathcal{U}} P(x, \refl) \to \prod_{y: A} \prod_{p : (x = y)} P(y,p)\]

Wich reads `If $P$ is a postulate on $y$ equal to $x$, and $P(x,refl)$ holds, then for any $y$ equal to $x$ over any path $p$, $P(x,y)$ holds.'

We note that if $p,q : (x = y)$, there is also a type $(p = q)$ which may or may not be inhabited. In fact there is an infinite structure of equalities between paths. This is where Homotopy Type Theory (HoTT) comes in: $x$ and $y$ are points of $A$, $p$ and $q$ are paths in that space from $x$ to $y$ (think continuous function $\left[ 0;1\right] \to A$). Inhabitants of $(p = q)$ are homotopies between these paths etc\ldots Reflexivity is the constant path, but there may be different paths that are not homotopic. Points in the path may be thought of as inhabitants of that space.

INSERT DRAWING

Following this interpretation, the type of equalities of a point $a$ in a type $A$ is perfectly analogous to the loop-space of $a$ in the space $A$. Therefor we define the loop operator, which maps a \emph{pointed type} (a type and an inhabitant) to its loop space.

\[\Omega(A , a_0) :\equiv (a_0 = a_0)\]

\subsection{Type Levels}

We've just seen how two inhabitants of $(x = y)$ may be equal, but we may like to work with types in which all equalities are unique. Let us generalize and formalize this idea:

\begin{definition}
  We say a type $A$ is a \emph{Proposition} if all of it's inhabitants are equal.
  \[\isprop(A) :\equiv \prod_{x,y : A}(x = y)\]
\end{definition}

\begin{definition}
  We say that a type is a \emph{Set} if all of it's identity types are propositions. We say that a type is a \emph{Groupoïd} if all of it's identity types are sets. In general we call an \emph{$n$-type} any type who's identity types at level $n$ are propositions (A proposition is called an $(-1)$-type).
\end{definition}

Note that a proposition is always a set, which is always a groupoïd, etc\ldots. In fact, seeing this allows one to show that $\isprop(A)$ is itself a proposition.

INSERT DRAWING

\subsection{Equivalences and  Univalence Axiom}

\begin{definition}
  A function $f : A \to B$ is said to be an \emph{equivalence} if it has an left and a right inverse:
  \[\isequiv(f) :\equiv \left(  \sum_{g : B \to A} f \circ g = \id_{B} \right) \times \left(  \sum_{h : B \to A}h \circ f = \id_{A} \right) \]
\end{definition}

It is important to note that most natural definitions of an equivalence are logically equivalent to this one, however this is the simplest definition that is propositionnal. We now come to one of the most important points of Homotopy Type Theory:

\begin{definition}
  We say that two types are \emph{equivalent} if there is an equivalence between them:
  \[(A \simeq B) :\equiv \sum_{f : A \to B} \isequiv(f) \]
\end{definition}

The identity function on a given type is obviously an equivalence, therefor by path induction one can define a very natural map:

\[\pathtoequiv : (A =_{\mathcal{U}} B) \to (A \simeq B)\]

\begin{axiom}[Univalence]
  The function $\pathtoequiv$ is an equivalence. Namely:
  \[(A = B) \simeq (A \simeq B)\]
\end{axiom}

This axiom, introduced by Voevodsky in 2006, is one of the key features of Homotopy Type Theory. One powerful application of this axiom is that if two algebraic structures are isomorphic, they can be identified. In classical logic mathematicians often consider these structures `up to isomorphism' and identify them seamlessly, univalence allows this formally. Let us study an example I formalized during my internship with the Agda proof-assistant: the structure of a G-set.

\subsection{Transport}

One subtlety with propositionnal equality is dealing with dependant types: if $P$ is a proposition over a type $X$, and $x,y : X$, even if $(x = y)$ is inhabited, $(P(x) = P(y))$ does not make any sense : there is no reason for $P(x)$ and $P(y)$ to be of the same type! However, path induction allows us to construct a \emph{transport}:

\[\transp : \prod_{p : (x = y)} P(x) \to P(y) \]

Which reads: `for any path $p$ from $x$ to $y$, we can construct a function $p^{*}$ that maps from $P(x)$ to $P(y)$'. It follows that $P(x)$ and $P(y)$ are logically equivalent, and so equality behaves as expected. Furthermore, one can show that equality for dependant pairs has a convenient shape:

\[(a, b) = (a', b') \simeq \sum_{p : a = a'}p^*(b) = b'\]

Which reads: `Two objects with structure are equal if and only if the objects are equal, and the transported structure of the first is equal to the structure of the second'. (Note that for non-dependant pairs one only needs to show that the two components are equal).

\section{An Example of Algebraic Structures in HoTT:\  G-Sets}

Before we dive in, a few notes on HoTT in Agda. The cubical library is the most commonly used implementation of HoTT in the Agda proof assistant (which is based on classical dependant type theory). It implements a specific branch called Cubical HoTT, which uses a formal interval $I$ which behaves like $[0;1]$, and is used to build paths. The cubical library has many results already formalized and checked in agda. I will mark those that I have checked in agda during my internship with the label (agd*), and those that I have proved on paper (pap*). All proofs are available in the appendix.


\subsection{Groups in HoTT}

Groups in HoTT are defined as a tuple (nested sum-type):

\begin{itemize}
    \item $G : \mathcal{U}$
    \item $1_{G} : G$
    \item $\mu : G \to G \to G$
    \item $\iota : G \to G$
\end{itemize}

As well as proofs that:

\begin{itemize}
    \item $G$ is a set ($\isset(G)$)
    \item $\mu$ is associative ($\prod_{x,y,z : G} \mu(x,(\mu(y,z))) = \mu(\mu(x,y),z)$)
    \item $1_{G}$ is a neutral element (both left and right)
    \item $\iota(g)$ is an inverse of $g$ (both left and right)
\end{itemize}

We will often note G both the carrier of the group (the underlying set) and the group itself, and $\_\cdot\_$ the group multiplication. We can define the type of all groups to be the sum-type of types in $\mathcal{U}$ along with a $\mu$ and $\iota$, that satisfy these conditions.

\subsection{Group Actions and G-Sets}

A Group Action of $G \curvearrowright X$ is a tuple :

\begin{itemize}
        \item $\mu : G \to X \to X$
\end{itemize}
Along with proofs of:
\begin{itemize}
        \item $\displaystyle\prod_{x : X} \mu(1_{G}, x) = x $
        \item $\displaystyle\prod_{g_1, g_2 : G}\prod_{x : X} \mu(g_1 \cdot g_2, x) = \mu(g_1, \mu(g_2,x)) $
        \item $\isset(X)$
\end{itemize}

And a $G$-Set is a carrier $X : \mathcal{U}$ and an action of $G$ on $X$. (Note that $X$ must therefore be a set). A morphism of $G$-Sets $X$ and $Y$ is a function between carriers $f : X \to Y$ that respects the actions : $f(\mu_{X}(g,x)) = \mu_{Y}(g,f(x))$. When $f$ is an equivalence, we call it an $G$-Set isomorphism. Let us show that isomorphic $G$-Sets can be identified.

\subsection{From Isomorphisms to Paths}

\end{document}
